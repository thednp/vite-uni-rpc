// packages/vite-plugin-trpc/src/plugin.ts
import type { Plugin } from 'vite'
// import MagicString from 'magic-string'
import { createHash } from 'node:crypto'
import { readBody } from './utils'
import { serverFunctionsMap } from './serverFunctionsMap'

import { fileURLToPath } from "node:url";
import { dirname, resolve } from "node:path";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const toAbsolute = (p:string) => resolve(__dirname, p);

export default function trpcPlugin(): Plugin {
  // const serverFiles = new Set<string>()

  const VIRTUAL_MODULE_PREFIX = 'virtual:@rpc/';
  const RESOLVED_VIRTUAL_MODULE_PREFIX = '\0' + VIRTUAL_MODULE_PREFIX;
  const REGISTRY_MODULE_ID = 'virtual:@rpc-registry/entries';
  const RESOLVED_REGISTRY_MODULE_ID = '\0' + REGISTRY_MODULE_ID;
  // let registeredFunctions = new Set();

  return {
    name: 'vite-plugin-rpc',
    enforce: 'pre',
    resolve: {
      alias: {
        "virtual:@rpc-registry": toAbsolute("./serverFunctionsMap.ts"),
      },
      ssr: {
        noExternal: ["virtual:@rpc-registry", "virtual:@rpc/*"]
      }
    },

    buildStart() {
      // registeredFunctions.clear();
      serverFunctionsMap.clear();
    },
    resolveId(source: string) {
      if (source === REGISTRY_MODULE_ID) {
        return RESOLVED_REGISTRY_MODULE_ID
      }
      if (source.startsWith(VIRTUAL_MODULE_PREFIX)) {
        // Important: return the resolved virtual module ID
        return RESOLVED_VIRTUAL_MODULE_PREFIX + source.slice(VIRTUAL_MODULE_PREFIX.length)
      }
      return null
    },

    load(id: string) {
      // if (id === RESOLVED_REGISTRY_MODULE_ID) {
      //   console.log('Loading registry with functions:', Array.from(registeredFunctions))
      //   return `
      //   // export const serverFunctionsMap = ${serverFunctionsMap};
      //   export const registeredFunctions = ${JSON.stringify(Array.from(registeredFunctions))};
      //   `
      // }
      if (id.startsWith(RESOLVED_VIRTUAL_MODULE_PREFIX)) {
        const fnName = id.slice(RESOLVED_VIRTUAL_MODULE_PREFIX.length)
        return `
          export default async function ${fnName}(...args) {
            const response = await fetch('/__rpc/${fnName}', {
              method: 'POST',
              headers: { 
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(args)
            });
            if (!response.ok) throw new Error('RPC call failed: ' + response.statusText);
            const result = await response.json();
            if (result.error) throw new Error(result.error);
            return result.data;
          }
        `
      }
      return null
    },

    transform(code: string, id: string, { ssr }: { ssr: boolean }) {
      // Only transform files with server functions
      if (!code.includes('createServerFunction')) {
        return null
      }
      console.log("transform", { id, ssr })


      if (ssr) {
        // In SSR mode, let Vite handle it
        return null
      }

      // Client-side: Replace all server functions with virtual module imports
      // const matches = Array.from(code.matchAll(/export\s+(?:function|const|let|var)\s+(\w+)\s*=\s*createServerFunction\s*\(\s*['"]([^'"]+)['"]/g))
      // if (matches.length === 0) return null
      // for (const [, name] of matches) {
      //   console.log("createServerFunction called:", name)
      //   registeredFunctions.add(name);
      // }

      console.log('Client: Transforming server file with functions:', Array.from(serverFunctionsMap));
      if (!id.includes("node_modules") /*&& (id.includes('api/server.ts') || id.includes('api/server.js'))*/) {
        const fnNames = Array.from(serverFunctionsMap.keys());
        
        // Generate imports for each function
        const imports = Array.from(fnNames)
          .map(name => `import ${name}Impl from '${VIRTUAL_MODULE_PREFIX}${name}';`)
          .join('\n');
        
        // Generate exports for each function
        const exports = Array.from(fnNames)
          .map(name => `export const ${name} = ${name}Impl;`)
          .join('\n');

        const transformedCode = `
          // Generated by vite-plugin-rpc
          ${imports}
          ${exports}
        `;

        console.log('Generated client code:', transformedCode);
        return {
          code: transformedCode,
          map: null
        };
      }
      return null;
    },

    // transform(code, id) {
    //   // Skip node_modules
    //   if (id.includes('node_modules')) return

    //   // Check for 'use server' directive at file level
    //   const isServerFile = code.trim().startsWith("'use server'") || 
    //                       code.trim().startsWith('"use server"')

    //   if (isServerFile) {
    //     serverFiles.add(id)
    //     // If client build, replace with proxy imports
    //     if (!isSSR) {
    //       return {
    //         code: generateClientProxy(id),
    //         map: null
    //       }
    //     }
    //     return
    //   }

    //   // Handle individual server functions
    //   if (code.includes('use server')) {
    //     if (!isSSR) {
    //       const s = new MagicString(code)
    //       // Transform server functions to client proxies
    //       return {
    //         code: transformServerFunctions(code, s),
    //         map: s.generateMap({ hires: true })
    //       }
    //     }
    //   }
    // },

    configureServer(server) {
      // Set CSRF token
      server.middlewares.use((req, res, next) => {
        if (req.method === 'GET') {
          const csrfToken = createHash('sha256').update(Date.now().toString()).digest('hex')
          res.setHeader('X-CSRF-Token', csrfToken)
        }
        next()
      })

      // Handle RPC calls
      server.middlewares.use(async (req, res, next) => {
        if (!req.url?.startsWith('/__rpc/')) return next()

        // Validate CSRF token
        const csrfToken = req.headers['x-csrf-token']
        if (!csrfToken) {
          res.statusCode = 403
          res.end(JSON.stringify({ error: 'Invalid CSRF token' }))
          return
        }

        const functionName = req.url.replace('/__rpc/', '')
        const serverFunction = serverFunctionsMap.get(functionName)

        if (!serverFunction) {
          res.statusCode = 404
          res.end(JSON.stringify({ error: 'Function not found' }))
          return
        }

        try {
          const body = await readBody(req)
          const args = JSON.parse(body || '[]')

          const result = await serverFunction.fn(...args)
          res.end(JSON.stringify({ data: result }))
        } catch (error) {
          res.statusCode = 500
          res.end(JSON.stringify({ error: String(error) }))
        }
      })
    }
  }
}
