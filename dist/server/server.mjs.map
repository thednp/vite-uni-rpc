{"version":3,"file":"server.mjs","names":[],"sources":["../../src/functionsMap.ts","../../src/scanForServerFiles.ts","../../src/options.ts","../../src/cache.ts","../../src/createFunction.ts","../../src/getClientModules.ts"],"sourcesContent":["import type { ServerFnEntry } from \"./types.d.ts\";\n\nexport const serverFunctionsMap = new Map<string, ServerFnEntry>();\nexport const functionMappings = new Map<string, string>();\n","import type { ResolvedConfig, ViteDevServer } from \"vite\";\nimport type { ServerFunction } from \"vite-uni-rpc\";\nimport { createServer } from \"vite\";\nimport { readdir } from \"node:fs/promises\";\nimport { join } from \"node:path\";\nimport process from \"node:process\";\n\nimport { functionMappings, serverFunctionsMap } from \"./functionsMap\";\n\ntype ScanConfig = Pick<ResolvedConfig, \"root\" | \"base\"> & {\n  server?: Partial<ResolvedConfig[\"server\"]>;\n};\n\nlet isScanned = false;\nexport const scanForServerFiles = async (\n  initialCfg?: ScanConfig,\n  devServer?: ViteDevServer,\n) => {\n  // ✅ Skip if already scanned\n  if (isScanned && !devServer) {\n    return;\n  }\n  functionMappings.clear();\n  let server = devServer;\n  const config =\n    (!initialCfg && !devServer) || !initialCfg\n      ? {\n          // always scan relative to the real root\n          root: process.cwd(),\n          base: process.env.BASE || \"/\",\n          server: { middlewareMode: true },\n        }\n      : {\n          ...initialCfg,\n          // always scan relative to the real root\n          root: process.cwd(),\n        };\n\n  if (!server) {\n    // const { createServer } = await import(\"vite\");\n    server = await createServer({\n      server: config.server,\n      appType: \"custom\",\n      base: config.base,\n      root: config.root,\n    });\n  }\n\n  const svFiles = [\"server.ts\", \"server.js\", \"server.mjs\", \"server.mts\"];\n  const apiDir = join(config.root, \"src\", \"api\");\n  const files = (await readdir(apiDir, { withFileTypes: true }))\n    .filter((f) => svFiles.some((fn) => f.name.includes(fn)))\n    .map((f) => join(apiDir, f.name));\n\n  try {\n    for (const file of files) {\n      try {\n        // Transform TypeScript to JavaScript using the loaded transform function\n        const moduleExports =\n          //server &&\n          (await server.ssrLoadModule(file)) as Record<string, ServerFunction>;\n        const moduleEntries = Object.entries(moduleExports);\n        if (!moduleEntries.length) {\n          console.warn(\"No server function found.\");\n          // Remember to always close the temporary dev server!\n          if (!devServer && server) {\n            await server.close();\n          }\n          return;\n        }\n        console.log({ moduleEntries });\n\n        // Examine each export\n        for (const [exportName, exportValue] of moduleEntries) {\n          serverFunctionsMap.set(exportName, {\n            name: exportName,\n            fn: exportValue as unknown as ServerFunction<never, never>,\n          });\n          // console.log(await exportValue());\n        }\n\n        for (const [exportName, exportValue] of moduleEntries) {\n          console.log({ exportName, exportValue, serverFunctionsMap });\n\n          for (const [\n            registeredName,\n            serverFn,\n          ] of serverFunctionsMap.entries()) {\n            console.log({ registeredName, serverFn });\n            if (\n              serverFn.name === registeredName &&\n              (serverFn.fn as unknown as ServerFunction) === exportValue\n            ) {\n              functionMappings.set(registeredName, exportName);\n            }\n          }\n        }\n        // Remember to always close the temporary dev server!\n        // if (!devServer) {\n        //   await server.close();\n        // }\n      } catch (error) {\n        console.error(\"Error loading file:\", file, error);\n      }\n    }\n  } finally {\n    // ✅ Only close if we created the server\n    if (!devServer && server) {\n      await server.close();\n    }\n    // ✅ Mark as scanned\n    isScanned = true;\n  }\n\n  console.log({ files }, isScanned, functionMappings, serverFunctionsMap);\n};\n","import type {\n  MiddlewareOptions,\n  RpcPluginOptions,\n  ServerFunctionOptions,\n} from \"./types.d.ts\";\n\nexport const defaultServerFnOptions = {\n  contentType: \"application/json\",\n  ttl: 10 * 1000, // 10s\n  invalidateKeys: [],\n} satisfies ServerFunctionOptions;\n\nexport const defaultRPCOptions = {\n  rpcPreffix: \"__rpc\",\n  adapter: \"express\",\n  headers: undefined,\n  onError: undefined,\n  onRequest: undefined,\n  onResponse: undefined,\n} satisfies RpcPluginOptions;\n\nexport const defaultMiddlewareOptions = {\n  // rpcPreffix: defaultRPCOptions.rpcPreffix,\n  rpcPreffix: undefined,\n  path: undefined,\n  headers: {} as Record<string, string>,\n  handler: undefined,\n  onError: undefined,\n  onRequest: undefined,\n  onResponse: undefined,\n} satisfies MiddlewareOptions;\n","// /vite-uni-rpc/src/cache.ts\nimport type { CacheEntry } from \"./types.d.ts\";\nimport { defaultServerFnOptions } from \"./options.ts\";\n\nexport class ServerCache {\n  private cache: Map<string, CacheEntry<unknown>> = new Map<\n    string,\n    {\n      data: unknown;\n      timestamp: number;\n      promise?: Promise<unknown>;\n    }\n  >();\n\n  async get<T>(\n    key: string,\n    ttl: number = defaultServerFnOptions.ttl,\n    fetcher: () => Promise<T>,\n  ): Promise<T> {\n    const entry = this.cache.get(key) as CacheEntry<T>;\n    const now = Date.now();\n\n    if (entry?.promise) return entry.promise;\n    if (entry?.data && now - entry.timestamp < ttl) return await entry.data;\n\n    const promise = fetcher().then((data) => {\n      this.cache.set(key, { data, timestamp: now });\n      return data;\n    });\n\n    this.cache.set(key, { ...entry, promise });\n    return promise;\n  }\n\n  invalidate(pattern?: string | string[] | RegExp | RegExp[]) {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    for (const key of this.cache.keys()) {\n      if (typeof pattern === \"string\" && key.includes(pattern)) {\n        this.cache.delete(key);\n        break;\n      } else if (pattern instanceof RegExp && pattern.test(key)) {\n        this.cache.delete(key);\n        break;\n      } else if (pattern instanceof Array) {\n        for (const p of pattern) {\n          if (typeof p === \"string\" && key.includes(p)) {\n            this.cache.delete(key);\n            break;\n          } else if (p instanceof RegExp && p.test(key)) {\n            this.cache.delete(key);\n            break;\n          }\n        }\n      }\n    }\n  }\n}\n\nexport const serverCache = new ServerCache();\n","// /vite-uni-rpc/src/createFn.ts\nimport { serverCache } from \"./cache.ts\";\nimport type {\n  JsonValue,\n  JsonArray,\n  ServerFnArgs,\n  ServerFunction,\n  ServerFunctionOptions,\n  ClientFunction,\n  ServerFunctionInit,\n} from \"./types.d.ts\";\nimport { serverFunctionsMap } from \"./functionsMap.ts\";\nimport { defaultServerFnOptions } from \"./options.ts\";\n\nexport function createServerFunction<\n  TArgs extends JsonArray = JsonArray,\n  TResult extends JsonValue = JsonValue,\n>(\n  name: string,\n  fn: ServerFunctionInit<TArgs, TResult>,\n  fnOptions: Partial<ServerFunctionOptions> = {},\n) {\n  const options = Object.assign({}, defaultServerFnOptions, fnOptions);\n  const wrappedFunction = async (\n    _signal: AbortSignal,\n    ...args: ServerFnArgs\n  ) => {\n    // if (signal.aborted) {\n    //   throw new Error(\"Operation aborted\");\n    // }\n    const cacheKey = `${name}:${JSON.stringify(args)}`;\n    const result = await serverCache.get(cacheKey, options.ttl, async () =>\n      (fn as unknown as ClientFunction<TArgs, TResult>)(...(args as TArgs)),\n    );\n\n    if (options.invalidateKeys) {\n      serverCache.invalidate(options.invalidateKeys);\n    }\n\n    return result;\n  };\n  // registerServerFunction(name, wrappedFunction, options);\n  serverFunctionsMap.set(name, {\n    name,\n    // plugin makes this shift no worry here\n    fn: wrappedFunction as unknown as ServerFunction<never, never>,\n    options,\n  });\n\n  // console.log(`✅ wrappedFn now has fnOptions:`, fnOptions); // ✅ DEBUG\n\n  console.log(\n    `✅ serverFunctionsMap now has:`,\n    Array.from(serverFunctionsMap.entries()).map(([k, v]) => [k, v.options]),\n  ); // ✅ DEBUG\n\n  return wrappedFunction as unknown as ClientFunction<TArgs, TResult>;\n}\n","// vite-uni-rpc/src/utils.ts\nimport type { RpcPluginOptions, ServerFunctionOptions } from \"./types.d.ts\";\n\nimport { serverFunctionsMap, functionMappings } from \"./functionsMap.ts\";\n\nconst getModule = (\n  fnName: string,\n  fnEntry: string,\n  options: Partial<ServerFunctionOptions> & {\n    contentType: ServerFunctionOptions[\"contentType\"];\n    rpcPreffix: string;\n  },\n) => {\n  console.log(\"getModule.options\", options);\n  let bodyHandling;\n  switch (options.contentType) {\n    case \"text/plain\":\n      bodyHandling = `\n    const body = args[0];\n    const headers = {\n      'Content-Type': 'text/plain'\n    };`;\n      break;\n    default:\n      bodyHandling = `\n    const body = JSON.stringify(args);\n    const headers = {\n      'Content-Type': 'application/json'\n    };`;\n  }\n\n  return `\n  export const ${fnEntry} = (...args) => {\n    const controller = new AbortController();\n    const cancel = (reason) => controller.abort(reason);\n    ${bodyHandling}\n    // const fetcher = async () => {\n    //   const response = await fetch('/${options.rpcPreffix}/${fnName}', {\n    //     method: 'POST',\n    //     headers: headers,\n    //     credentials: 'include',\n    //     body: body,\n    //     signal: controller.signal,\n    //   });\n    //   return await handleResponse(response);\n    // }\n    const fetcher = async () => {\n      try {\n      const response = await fetch('/${options.rpcPreffix}/${fnName}', {\n          method: \"POST\",\n          headers,\n          credentials: \"include\",\n          body,\n          signal: controller.signal\n        });\n        return await handleResponse(response);\n      } catch (err) {\n        // ✅ Handle abort specifically\n        if (err.name === \"AbortError\") {\n          throw new Error(\"Request cancelled by user\");\n        }\n        throw err;\n      }\n    };\n\n    return {\n      data: fetcher(),\n      cancel,\n    };\n  }`;\n};\n\nexport const getClientModules = (initialOptions: RpcPluginOptions) => {\n  console.log(\"getClientModules.functionMappings\", functionMappings);\n  return `\n// Client-side RPC modules\nconst handleResponse = async (response) => {\n  console.log(\"handleResponse\", response)\n  if (!response.ok) {\n    if (response.status === 499 || response.status === 408) {\n      throw new Error(\"Request was cancelled\");\n    }\n    throw new Error('Fetch error: ' + response.statusText);\n  }\n  const result = await response.json();\n  if (result.error) throw new Error(result.error);\n  return result.data;\n}\n${Array.from(functionMappings.entries())\n  .map(([registeredName, exportName]) =>\n    getModule(registeredName, exportName, {\n      ...initialOptions,\n      ...((serverFunctionsMap.get(registeredName)\n        ?.options as ServerFunctionOptions) || {}),\n    }),\n  )\n  .join(\"\\n\")}\n`.trim();\n};\n"],"mappings":"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"}