{"version":3,"file":"express.mjs","names":[],"sources":["../../src/options.ts","../../src/express/helpers.ts","../../src/express/createMiddleware.ts"],"sourcesContent":["import type {\n  MiddlewareOptions,\n  RpcPluginOptions,\n  ServerFunctionOptions,\n} from \"./types.d.ts\";\n\nexport const defaultServerFnOptions = {\n  contentType: \"application/json\",\n  ttl: 10 * 1000, // 10s\n  invalidateKeys: [],\n} satisfies ServerFunctionOptions;\n\nexport const defaultRPCOptions = {\n  rpcPreffix: \"__rpc\",\n  adapter: \"express\",\n  headers: undefined,\n  onError: undefined,\n  onRequest: undefined,\n  onResponse: undefined,\n} satisfies RpcPluginOptions;\n\nexport const defaultMiddlewareOptions = {\n  // rpcPreffix: defaultRPCOptions.rpcPreffix,\n  rpcPreffix: undefined,\n  path: undefined,\n  headers: {} as Record<string, string>,\n  handler: undefined,\n  onError: undefined,\n  onRequest: undefined,\n  onResponse: undefined,\n} satisfies MiddlewareOptions;\n","// src/express/helpers.ts\nimport type { IncomingMessage, ServerResponse } from \"node:http\";\nimport type {\n  Request as ExpressRequest,\n  Response as ExpressResponse,\n} from \"express\";\nimport type { BodyResult, JsonValue } from \"vite-uni-rpc\";\n\n// src/express/helpers.ts\nexport const readBody = (\n  req: ExpressRequest | IncomingMessage,\n  signal?: AbortSignal,\n): Promise<BodyResult> => {\n  return new Promise((resolve, reject) => {\n    let body = \"\";\n\n    // ✅ Check if already aborted\n    if (signal?.aborted) {\n      reject(\"Request aborted\");\n      return;\n    }\n\n    // ✅ Listen for abort during body reading\n    const onAbort = () => {\n      reject(\"Request aborted\");\n      // Clean up listeners\n      req.removeListener(\"data\", onData);\n      req.removeListener(\"end\", onEnd);\n      req.removeListener(\"error\", onError);\n    };\n\n    if (signal) {\n      signal.addEventListener(\"abort\", onAbort);\n    }\n\n    const onData = (chunk: Buffer) => {\n      body += chunk.toString();\n    };\n\n    const onEnd = () => {\n      // Clean up abort listener\n      if (signal) {\n        signal.removeEventListener(\"abort\", onAbort);\n      }\n\n      try {\n        resolve({ contentType: \"application/json\", data: JSON.parse(body) });\n      } catch (_e) {\n        // If JSON parse fails, treat as text\n        resolve({ contentType: \"text/plain\", data: body });\n      }\n    };\n\n    const onError = (err: Error) => {\n      // Clean up abort listener\n      if (signal) {\n        signal.removeEventListener(\"abort\", onAbort);\n      }\n      reject(err);\n    };\n\n    req.on(\"data\", onData);\n    req.on(\"end\", onEnd);\n    req.on(\"error\", onError);\n  });\n};\n\nexport const isExpressRequest = (\n  req: IncomingMessage | ExpressRequest,\n): req is ExpressRequest => {\n  return \"originalUrl\" in req;\n};\n\nexport const isExpressResponse = (\n  res: ServerResponse | ExpressResponse,\n): res is ExpressResponse => {\n  return \"json\" in res && \"send\" in res;\n};\n\nexport const getRequestDetails = (\n  request: ExpressRequest | IncomingMessage,\n) => {\n  const rawUrl = (\n    isExpressRequest(request) ? request.originalUrl : request.url\n  ) as string;\n  const url = new URL(rawUrl, \"http://localhost\");\n\n  return {\n    url: url.pathname,\n    search: url.search,\n    searchParams: url.searchParams,\n    headers: request.headers,\n    method: request.method,\n  };\n};\n\nexport const getResponseDetails = (\n  response: ExpressResponse | ServerResponse,\n) => {\n  const isResponseSent = response.headersSent || response.writableEnded;\n\n  const setHeader = (name: string, value: string) => {\n    if (isExpressResponse(response)) {\n      response.header(name, value);\n    } else {\n      response.setHeader(name, value);\n    }\n  };\n\n  const setStatusCode = (code: number) => {\n    if (isExpressResponse(response)) {\n      response.status(code);\n    } else {\n      response.statusCode = code;\n    }\n  };\n\n  const sendResponse = (code: number, output: Record<string, JsonValue>) => {\n    setStatusCode(code);\n\n    if (isExpressResponse(response)) {\n      response.send(JSON.stringify(output));\n    } else {\n      response.end(JSON.stringify(output));\n    }\n  };\n\n  return {\n    isResponseSent,\n    setHeader,\n    statusCode: response.statusCode,\n    setStatusCode,\n    sendResponse,\n  };\n};\n","// src/express/createMidleware.ts\nimport type { IncomingMessage, ServerResponse } from \"node:http\";\nimport type {\n  NextFunction,\n  Request as ExpressRequest,\n  Response as ExpressResponse,\n} from \"express\";\nimport type { Connect } from \"vite\";\n// import { scanForServerFiles } from \"vite-uni-rpc/server\";\nimport { serverFunctionsMap } from \"vite-uni-rpc/server\";\n// import { serverFunctionsMap, scanForServerFiles } from \"../../src/server.ts\";\nimport { defaultMiddlewareOptions, defaultRPCOptions } from \"../options.ts\";\nimport { getRequestDetails, getResponseDetails, readBody } from \"./helpers.ts\";\nimport type {\n  ExpressMiddlewareFn,\n  ExpressMiddlewareOptions,\n} from \"./types.d.ts\";\n\n// import { JsonArray, JsonValue, ServerFunction } from \"../types\";\nimport type { JsonValue, ServerFunction } from \"vite-uni-rpc\";\n\nlet middlewareCount = 0;\nconst middleWareStack = new Set<string>();\n\nexport const createMiddleware: ExpressMiddlewareFn = (initialOptions = {}) => {\n  const {\n    name: middlewareName,\n    rpcPreffix,\n    path,\n    headers,\n    handler,\n    onRequest,\n    onResponse,\n    onError,\n  } = Object.assign(\n    {},\n    defaultMiddlewareOptions,\n    initialOptions,\n  ) as ExpressMiddlewareOptions;\n\n  let name = middlewareName;\n  if (!name) {\n    name = \"viteRPCMiddleware-\" + middlewareCount;\n    middlewareCount += 1;\n  }\n  if (middleWareStack.has(name)) {\n    throw new Error(`The middleware name \"${name}\" is already used.`);\n  }\n\n  const middlewareHandler = async (\n    req: IncomingMessage | ExpressRequest,\n    res: ServerResponse | ExpressResponse,\n    next: Connect.NextFunction | NextFunction,\n  ) => {\n    const { url } = getRequestDetails(req);\n    const { sendResponse, setHeader } = getResponseDetails(res);\n    // When serving from production server, it's a good idea to\n    // scan for server files and populate the serverFunctionsMap\n    // if (serverFunctionsMap.size === 0) {\n    //   // Let the utility use its own defaults\n    //   await scanForServerFiles();\n    // }\n    // No need to continue when no handler provided\n    if (!handler) {\n      return next?.();\n    }\n\n    try {\n      // Execute onRequest hook if provided\n      if (onRequest) {\n        await onRequest(req);\n      }\n      // Path matching\n      if (path) {\n        const matcher = typeof path === \"string\" ? new RegExp(path) : path;\n        if (!matcher.test(url || \"\")) return next?.();\n      }\n      // rpcPreffix matching\n      if (rpcPreffix && !url?.startsWith(`/${rpcPreffix}`)) {\n        return next?.();\n      }\n\n      // Set custom headers\n      if (headers) {\n        Object.entries(headers).forEach(([key, value]) => {\n          setHeader(key, value);\n        });\n      }\n\n      // Execute handler if provided\n      if (handler) {\n        await handler(req, res, next);\n        if (onResponse) {\n          await onResponse(res);\n        }\n        return;\n      }\n\n      next?.();\n    } catch (error) {\n      if (onResponse) {\n        await onResponse(res);\n      }\n      if (onError) {\n        onError(error as Error, req, res);\n      } else {\n        console.error(\"Middleware error:\", String(error));\n        sendResponse(500, { error: \"Internal Server Error\" });\n      }\n    }\n  };\n\n  Object.defineProperty(middlewareHandler, \"name\", {\n    value: name,\n  });\n\n  return middlewareHandler;\n};\n\n// Create RPC middleware\nexport const createRPCMiddleware: ExpressMiddlewareFn = (\n  initialOptions = {},\n) => {\n  const options = Object.assign(\n    {},\n    defaultMiddlewareOptions,\n    { rpcPreffix: defaultRPCOptions.rpcPreffix },\n    initialOptions,\n  ) as ExpressMiddlewareOptions;\n\n  return createMiddleware({\n    ...options,\n    handler: async (\n      req: IncomingMessage | ExpressRequest,\n      res: ServerResponse | ExpressResponse,\n      next: NextFunction | Connect.NextFunction,\n    ) => {\n      const { url } = getRequestDetails(req);\n      const { sendResponse } = getResponseDetails(res);\n      const { rpcPreffix } = options;\n\n      if (!url?.startsWith(`/${rpcPreffix}`)) {\n        return next?.();\n      }\n\n      const functionName = url.replace(`/${rpcPreffix}/`, \"\");\n      const serverFunction = serverFunctionsMap.get(functionName);\n\n      if (!serverFunction) {\n        sendResponse(404, { error: `Function \"${functionName}\" not found` });\n        return;\n      }\n\n      // console.log((req as ExpressRequest).app);\n\n      try {\n        const controller = new AbortController();\n        req.addListener(\"close\", (e) => {\n          console.log(\"Operation Aborted\", e);\n          controller.abort(\"Operation Aborted\");\n        });\n        req.addListener(\"error\", (e) => {\n          console.log(\"Request Error\", e);\n\n          // controller.abort(\"Request Error\");\n        });\n        const body = await readBody(req, controller.signal);\n\n        // const signal = req.headers[\"signal\"] as AbortSignal | undefined;\n        const args = Array.isArray(body.data) ? body.data : [body.data];\n        const result = await ((serverFunction.fn as unknown as ServerFunction)(\n          controller.signal,\n          ...args,\n        ) as Promise<JsonValue>);\n\n        console.log(\"express.middleware\", result);\n        // sendResponse(200, { data: result });\n        if (!res.headersSent) {\n          sendResponse(200, { data: result });\n        }\n      } catch (err) {\n        // ✅ Detect abort errors\n        // if (err instanceof Error && err.message.includes(\"abort\")) {\n        //   console.log(\"✅ Request cancelled by client\");\n        //   if (!res.headersSent) {\n        //     sendResponse(408, { error: \"Request cancelled\" });\n        //   }\n        //   return;\n        // }\n        console.error(String(err));\n        sendResponse(500, { error: \"Internal Server Error\" });\n      }\n    },\n  });\n};\n"],"mappings":"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"}